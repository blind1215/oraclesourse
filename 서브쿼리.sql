-- 존스의 급여보다 높은 급여를 받는 사원들을 출력하기
--1.존스의 급여 알아내기
SELECT SAL FROM EMP WHERE ENAME='JONES';

--높은 급여 사원 출력하기 
SELECT * FROM EMP WHERE SAL > 2975;

-- 서브쿼리 : 쿼리문 안에 다른 쿼리문을 포함하고 있는 상태
-- 단일행 서브쿼리 : >,< ,= <= , >=, 같지않음 : <> ,^=,!=
SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME='JONES');

--사원이름이 ALLEN인 사원의 추가수당보다 많이 받는 사원을 출력
SELECT * FROM EMP WHERE COMM >(SELECT COMM FROM EMP WHERE ENAME='ALLEN');

--사원이름이 WARD 인 사원의 입사일보다 빨리 입사한 사원을 출력
SELECT * FROM EMP WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME='WARD');

--20번 부서에 속한 사원 중 전체 사원의 평균 급여보다 높은 급여를 받는 사원 출력

SELECT * FROM EMP WHERE DEPTNO= 20 AND SAL > (SELECT AVG(SAL) FROM EMP );

-- 20번 부서에 속한 사원 중 전체 사원의 평균 급여보다 높은 급여를 받는 사원의 정보 출력
--부서명, 지역위치 출력하도록 한다.
SELECT E.EMPNO,E.ENAME,E.SAL,D.DEPTNO,D.DNAME,D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.DEPTNO = 20 AND SAL > (SELECT AVG(SAL) FROM EMP); 

-- 다중행 서브쿼리

--서브쿼리 결과가 2개 이상 나오는 경우라면 단일행 서브쿼리의 연산자 사용불가
--단일 행 하위 질의에 2개 이상의 행이 리턴되었습니다. (단일행연산자를 썼기때문에 나온에러)
SELECT *FROM EMP WHERE SAL >= (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT * FROM EMP GROUP BY DEPTNO;
--IN
SELECT *FROM EMP WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

--ANY(SOME)애니앞에 기호를 사용해야함
-- =ANY : IN의 수행 결과와 같게 나옴 , 단 IN을 더 많이 사용함
SELECT *FROM EMP WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT *FROM EMP WHERE SAL = SOME (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

--30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원 출력
SELECT * FROM EMP WHERE DEPTNO=30;
SELECT * FROM EMP WHERE SAL < ANY (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);

SELECT * FROM EMP WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30);

SELECT DISTINCT SAL FROM EMP WHERE DEPTNO=30;

--30번 부서 사원들의 최소 급여보다 많은 급여를 받는 사원 출력

SELECT * FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30);

--ALL (모두만족해야함) : 서브 쿼리의 결과를 모두 만족하는 메인쿼리를 추출할 때
--부서번호가 30번인 사원들의 최소 급여보다 더 적은 급여를 받는 사원 출력

SELECT * FROM EMP WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);

-- EXISTS : IN 과 비슷한 개념 , 단 IN 보다 성능이 우수함 
-- 서브 쿼리 결과가 존재하면 메인쿼리 결과도 출력 

SELECT * FROM EMP WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO= 20);
SELECT * FROM EMP WHERE NOT EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO= 20);

SELECT EMPNO, DEPTNO 
FROM EMP 
WHERE EXISTS (SELECT DEPTNO 
              FROM DEPT 
              WHERE DEPTNO IN (20,30) AND EMP.DEPTNO = DEPTNO);
--부서번호가 20,30번이면서 EMP DEPTNP의 DEPTNP가같으면 EMP에서 EMPNO와 DEPTNP를 출력한다         


--서브쿼리의 웨어구절과 메인쿼리의 설렉트가 상응한다    
SELECT EMPNO, DEPTNO 
FROM EMP 
WHERE EXISTS (SELECT 1 
              FROM DEPT 
              WHERE DEPTNO IN (20,30) AND EMP.DEPTNO = DEPTNO);
              
SELECT EMPNO, DEPTNO 
FROM EMP 
WHERE NOT EXISTS (SELECT 1 
              FROM DEPT 
              WHERE DEPTNO IN (20,30) AND EMP.DEPTNO = DEPTNO);
              
--ppt(19) 연습문제

--전체 사원 중 ALLEN과 같은 직책인 사원들의 사원정보, 부서 정보를 출력하는 SQL문을 작성하시오
SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.JOB_ID = D.DEPTNO AND E.JOB_ID IN (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

--전체 사원의 평균 급여보다 높은 급여를 받는 사원들의 사원정보,부서정보, 급여 등급 정보를 출력
--(단, 출력할 때 급여가 많은 순으로 정렬 하되 급여가 같을 경우에는 사원 번호를 기준으로 오름차순)
SELECT E.EMPNO, E.ENAME, D.DNAME,E.HIREDATE,D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL AND E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO ASC;


--다중 열 서브쿼리 : 서브쿼리의 SELECT 문에 비교할 컬럼이 여러개 나오는 방식
SELECT * FROM EMP WHERE (DEPTNO,SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

--FROM 절에 사용하는 서브쿼리(인라인 뷰)
SELECT E.EMPNO,E.ENAME,D.DEPTNO,D.DNAME, D.LOC
FROM (SELECT*FROM EMP WHERE DEPTNO=10) E,(SELECT*FROM DEPT)D
WHERE E.DEPTNO = D.DEPTNO;

--SELECT 절에 사용하는 서브쿼리 - 스칼라 서브쿼리

--PPT23 실습1
--10번 부서에 근무하는 사원 중 30번 부서에는 존재하지 않는 직책을 가진
--사원들의 사원정보, 부서 정보를 다음과 같이 출력하는 SQL문을 작성하시오
SELECT E.EMPNO,E.ENAME, E.JOB, D.DEPTNO,D.DNAME,D.LOC
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO AND E.JOB NOT IN(SELECT DISTINCT JOB FROM EMP WHERE DEPTNO=30)
AND E.DEPTNO=10;

--직책에 SALESMAN인 사람들의 최고 급여보다 높은 급여를 받는 사원들의 사원정보,
--급여등급 정보를 출력하는 SQL문을 작성하시오 (단, 서브쿼리를 활용할 때 다중행 함수를
--사용하는 방법과 사용하지 않는 방법을 통해 사원번호를 기준으로 오름차순 정렬하여 출력하시오.
SELECT EMPNO,ENAME,SAL
FROM EMP
WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN');

SELECT EMPNO,ENAME,SAL
FROM EMP
WHERE SAL > ALL(SELECT SAL FROM EMP WHERE JOB='SALESMAN');

SELECT EMPNO,ENAME,SAL,(SELECT GRADE FROM SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL)AS GRADE
FROM EMP
WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN');
